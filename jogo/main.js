// Generated by CoffeeScript 2.7.0
var TRS, ajusta_posicao_wrap, apertando_tecla, apertou_tecla, arqs, atualiza_uniforms, c, carrega_dados, contador_spawn_asteroide, cria_asteroide, cria_coisa, cria_explosao, cria_explosao_nave, cria_nave, cria_tiro, gr, intervalo_spawn_asteroide, job, ls, main, mat, max_asteroides, multiplayer_connect_to_server, multiplayer_info, multiplayer_send_to_server, musica_fundo, musica_iniciada, nave, obj_quad, on_keydown, on_keyup, pipe_cor, pipe_tex, pos_inicial_nave, prepara_instancias, prepara_pipelines, prepara_shader_data_groups, prepara_teclado_eventos, processa_movimento, renderiza, res, reset_game, som_explosao, som_explosao_nave, som_tiro, teclas;

multiplayer_info = {
  ativado: true,
  porta: ':3000',
  socket: null,
  meu_id: '',
  jogadores: {},
  inst_dos_jogadores: {}
};

multiplayer_connect_to_server = function(servidor) {
  var url;
  if (!multiplayer_info.ativado) {
    return;
  }
  url = 'ws://' + servidor + multiplayer_info.porta;
  multiplayer_info.socket = new WebSocket(url);
  multiplayer_info.socket.onopen = function() {
    return console.log('--- Conectado ao servidor');
  };
  multiplayer_info.socket.onclose = function() {
    return console.log('--- Desconectado do servidor');
  };
  return multiplayer_info.socket.onmessage = function(event) {
    var conteudo, i, inst, jogador, jogador_id, len, meu_novo_id, msg_recebida, ref, results;
    //console.log "-- Recebeu msg: '#{event.data}'"
    msg_recebida = JSON.parse(event.data);
    switch (msg_recebida.assunto) {
      case 'seu novo id':
        meu_novo_id = msg_recebida.conteudo.id;
        console.log(`--- ID atribuído pelo servidor: ${meu_novo_id}`);
        multiplayer_info.meu_id = meu_novo_id;
        return document.title = "Jogador: " + meu_novo_id;
      case 'jogador entrou':
        jogador_id = msg_recebida.conteudo.id;
        console.log(`--- Jogador entrou - id: ${jogador_id}`);
        // recebemos o aviso que entrou um jogador.
        // vamos criar uma instância pra ele e
        // aguardar a atualização do estado para
        // determinar a posição da instância, etc.

        inst = ls.instance(res.obj(arqs.nave), {
          pipeline: pipe_cor
        });
        multiplayer_info.inst_dos_jogadores[jogador_id] = inst;
        inst.set_class('multiplayer-nave');
        inst.pos = vec(0, 0, 0);
        return inst.ang = 0;
      case 'jogador saiu':
        jogador_id = msg_recebida.conteudo.id;
        console.log(`--- Jogador saiu - id: ${jogador_id}`);
        // um jogador saiu. vamos remover a instância dele.
        multiplayer_info.inst_dos_jogadores[jogador_id].remove();
        return delete multiplayer_info.inst_dos_jogadores[jogador_id];
      case 'estado atual de todos':
        multiplayer_info.jogadores = msg_recebida.conteudo.jogadores;
        ref = multiplayer_info.jogadores;
        // recebemos o estado geral da partida,
        // contendo os dados de todos os jogadores.

        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          jogador = ref[i];
          // recebemos até o nosso próprio dado,
          // mas vamos ignorar ele.
          if (jogador.id === multiplayer_info.meu_id) {
            continue;
          }
          conteudo = jogador.conteudo;
          inst = multiplayer_info.inst_dos_jogadores[jogador.id];
          inst.pos = vec_from_array(conteudo.pos);
          results.push(inst.ang = conteudo.ang);
        }
        return results;
    }
  };
};

multiplayer_send_to_server = function() {
  var msg, ref;
  if (!multiplayer_info.ativado) {
    return;
  }
  if (((ref = multiplayer_info.socket) != null ? ref.readyState : void 0) === WebSocket.OPEN) {
    
    // envia meus dados para o servidor. o que eu enviar
    // é o que eu recebo dos outros tb.

    msg = JSON.stringify({
      assunto: 'enviando meu estado',
      conteudo: {
        pos: vec_to_array(nave.pos),
        ang: nave.ang
      }
    });
    return multiplayer_info.socket.send(msg);
  }
};

c = pipe_cor = pipe_tex = job = mat = res = ls = null;

gr = {
  dados_globais: null,
  dados_materiais: [],
  dados_instancias: null
};

arqs = {
  nave: 'data/nave_metal.ply',
  asteroide: 'data/asteroide_gelo.ply'
};

//sons
som_tiro = null;

som_explosao = null;

som_explosao_nave = null;

musica_fundo = null;

musica_iniciada = false;


// --- Controle de Spawn de Asteroides ---
contador_spawn_asteroide = 0;

intervalo_spawn_asteroide = 60; // Spawn a cada 120 frames (aprox. 2 segundos a 60fps)

max_asteroides = 15; // Número máximo de asteroides na tela

// ------------------------------------

//posicao inicial
pos_inicial_nave = null;

nave = null;

obj_quad = null;

teclas = {};

//posicao
main = async() => {
  c = (await wgpu_context_new({
    canvas: 'tela',
    debug: true,
    transparent: true
  }));
  c.frame_buffer_format('color', 'depth');
  c.vertex_format('xyz', 'rgba', 'uv');
  mat = c.use_mat4x4_format();
  await carrega_dados();
  prepara_shader_data_groups();
  prepara_pipelines();
  prepara_instancias();
  prepara_teclado_eventos();
  //multiplayer
  multiplayer_connect_to_server('10.80.60.124');
  job = c.job();
  return renderiza();
};

carrega_dados = async function() {
  musica_fundo = new Audio('data/sons/musica_fundo_doom.mp3');
  som_tiro = new Audio('data/sons/tiro.mp3');
  som_explosao = new Audio('data/sons/explosao_asteroide5.mp3');
  som_explosao_nave = new Audio('data/sons/nave_explodindo.mp3');
  res = c.resources_from_files(arqs.nave, arqs.asteroide, 'data/tiro_doom.png', 'data/sprites/sp[1-4].png', 'data/explosao1/explosao[0-6].png', 'data/explosao2/explosao[0-7].png', 'data/explosao3/explosao[0-5].png', 'shader_cor.wgsl', 'shader_tex.wgsl');
  return (await res.load_all());
};

prepara_shader_data_groups = function() {
  var u;
  gr.dados_globais = c.shader_data_group_with_uniform();
  u = gr.dados_globais.binding(0).get_uniform();
  u.begin();
  u.mat4x4('view');
  u.mat4x4('proj');
  u.end();
  u.proj = mat.perspective(50, c.canvas.width / c.canvas.height, 0.1, 10);
  u.view = mat.look_at(vec(0, 0, 8), vec(0, 0, 0), vec(0, 1, 0));
  u.gpu_send();
  gr.dados_materiais = res.materials_from_tex_list();
  gr.dados_instancias = c.shader_data_group_with_uniform_list(300);
  u = gr.dados_instancias.binding(0).get_uniform_list();
  u.begin();
  u.mat4x4('model');
  return u.end();
};

prepara_pipelines = function() {
  pipe_cor = c.pipeline();
  pipe_cor.begin('triangles');
  pipe_cor.shader_from_src(res.text('shader_cor.wgsl'));
  pipe_cor.depth_test(true);
  pipe_cor.expect_group(0).binding(0).uniform();
  pipe_cor.expect_group(2).binding(0).uniform_list();
  pipe_cor.end();
  pipe_tex = c.pipeline();
  pipe_tex.begin('triangles');
  pipe_tex.shader_from_src(res.text('shader_tex.wgsl'));
  pipe_tex.depth_test(true);
  pipe_tex.depth_write(false);
  pipe_tex.expect_group(0).binding(0).uniform();
  pipe_tex.expect_group(1).binding(0).tex();
  pipe_tex.expect_group(1).binding(1).tex_sampler();
  pipe_tex.expect_group(2).binding(0).uniform_list();
  return pipe_tex.end();
};

prepara_instancias = function() {
  var indices, vdata;
  vdata = [-0.5, -0.5, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, +0.5, -0.5, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0, +0.5, +0.5, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, -0.5, +0.5, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0];
  indices = [0, 1, 2, 2, 3, 0];
  obj_quad = c.obj_from_data(vdata, indices);
  ls = c.instance_list();
  ls.use_groups({
    global_index: 0,
    global_group: gr.dados_globais,
    material_index: 1,
    instance_index: 2,
    instance_group: gr.dados_instancias
  });
  pos_inicial_nave = vec(3, -2, 0);
  nave = cria_nave(vec(3, -2, 0));
  return cria_asteroide(vec(-4, 2, 0));
};

// Função para limpar a fase e recriar a nave
reset_game = function() {
  var ast, i, instancias_a_remover, len;
  // Pega uma cópia da lista de todos os asteroides atuais
  instancias_a_remover = ls.get_instances_by_class('asteroide').slice();
// Remove um por um
  for (i = 0, len = instancias_a_remover.length; i < len; i++) {
    ast = instancias_a_remover[i];
    ast.remove();
  }
  // Cria a nave novamente na sua posição original
  return nave = cria_nave(pos_inicial_nave);
};

cria_nave = function(pos) {
  var inst;
  inst = ls.instance(res.obj(arqs.nave), {
    pipeline: pipe_cor
  });
  inst.set_class('nave');
  inst.pos = pos;
  inst.vel = vec(0, 0, 0);
  inst.ang = 0;
  inst.frente = vec(0, 1, 0);
  return inst;
};

cria_asteroide = function(pos) {
  var ast, max_pos, min_pos, v_max, v_min;
  min_pos = vec(-3, -3, 0);
  max_pos = vec(+3, +3, 0);
  v_min = vec(-1, -1, 0);
  v_max = vec(+1, +1, 0);
  if (pos == null) {
    pos = vec_random(min_pos, max_pos);
  }
  ast = ls.instance(res.obj(arqs.asteroide), {
    pipeline: pipe_cor
  });
  ast.set_class('asteroide');
  ast.pos = pos;
  ast.vel = vec_random(v_min, v_max).mul_by_scalar(0.1);
  ast.ang = random(90);
  ast.size = 0.5;
  return ast;
};

cria_tiro = function(nave) {
  var inst;
  if (som_tiro != null) {
    som_tiro.currentTime = 0;
    som_tiro.volume = 0.1; // volume do som
    som_tiro.play(); // Toca o som
  }
  inst = ls.instance(obj_quad, {
    pipeline: pipe_tex,
    material: gr.dados_materiais[0]
  });
  inst.set_class('tiro');
  inst.pos = nave.pos;
  inst.vel = nave.frente;
  return inst.ang = 0;
};

cria_explosao = function(pos) {
  var inst;
  if (som_explosao != null) {
    som_explosao.currentTime = 0;
    som_explosao.volume = 0.2; // volume do som
    som_explosao.play();
  }
  inst = ls.instance(obj_quad, {
    pipeline: pipe_tex
  });
  inst.set_class('explosao');
  inst.pos = pos;
  inst.size = 2.0;
  return inst.start_animation_from_materials('data/explosao3/explosao[0-5].png', gr.dados_materiais, {
    on_animation_end: function(inst) {
      return inst.remove();
    }
  });
};

cria_explosao_nave = function(pos) {
  var inst;
  if (som_explosao_nave != null) {
    som_explosao_nave.currentTime = 0;
    som_explosao_nave.volume = 0.5; // volume do som
    som_explosao_nave.play();
  }
  inst = ls.instance(obj_quad, {
    pipeline: pipe_tex
  });
  inst.set_class('explosao');
  inst.pos = pos;
  inst.size = 2.0;
  return inst.start_animation_from_materials('data/explosao3/explosao[0-5].png', gr.dados_materiais, {
    on_animation_end: function(inst) {
      return inst.remove();
    }
  });
};

cria_coisa = function(pos) {
  var coisa, max_pos, min_pos, mt, url, v_max, v_min;
  min_pos = vec(-3, -3, 0);
  max_pos = vec(+3, +3, 0);
  v_min = vec(-1, -1, 0);
  v_max = vec(+1, +1, 0);
  if (pos == null) {
    pos = vec_random(min_pos, max_pos);
  }
  url = res.get_url_group_random_item('data/sprites/sp[1-4].png');
  mt = gr.dados_materiais.get_by_url(url);
  coisa = ls.instance(obj_quad, {
    pipeline: pipe_tex,
    material: mt
  });
  coisa.set_class('coisa');
  coisa.pos = pos;
  coisa.vel = vec_random(v_min, v_max).mul_by_scalar(0.1);
  coisa.size = 1.0;
  return coisa;
};

prepara_teclado_eventos = function() {
  document.addEventListener('keydown', on_keydown);
  return document.addEventListener('keyup', on_keyup);
};

on_keydown = function(event) {
  if (!musica_iniciada && (musica_fundo != null)) {
    musica_fundo.loop = true; // Para que a música repita
    musica_fundo.volume = 0.3;
    musica_fundo.play();
    musica_iniciada = true;
  }
  if (event.key === ' ') {
    event.preventDefault();
  }
  if (teclas[event.key] == null) {
    return teclas[event.key] = 1;
  } else {
    return teclas[event.key]++;
  }
};

on_keyup = function(event) {
  return teclas[event.key] = 0;
};

apertando_tecla = function(key) {
  return teclas[key] >= 1;
};

apertou_tecla = function(key) {
  var apertou;
  apertou = teclas[key] === 1;
  if (apertou) {
    return teclas[key] = 2;
  }
};

renderiza = function() {
  processa_movimento();
  atualiza_uniforms();
  job.render_begin();
  job.render_instance_list(ls);
  job.render_end();
  job.gpu_send();
  return c.animation_repeat(renderiza, 10);
};

ajusta_posicao_wrap = function(objeto, limite_x, limite_y) {
  if (objeto.pos.x > limite_x) {
    objeto.pos.x = -limite_x;
  } else if (objeto.pos.x < -limite_x) {
    objeto.pos.x = limite_x;
  }
  if (objeto.pos.y > limite_y) {
    return objeto.pos.y = -limite_y;
  } else if (objeto.pos.y < -limite_y) {
    return objeto.pos.y = limite_y;
  }
};

processa_movimento = function() {
  var R, ang_inc, ast, asteroides, asteroides_atuais, coisa, coisas, dist_sqr, dx, dy, fator, i, j, k, l, len, len1, len2, len3, len4, len5, limite_x, limite_y, m, n, raio_ast, raio_nave, raio_tiro, soma_raios_sqr, tiro, tiros, v, y_inc;
  limite_x = 6.5;
  limite_y = 4.0;
  fator = 0.1;
  asteroides = ls.get_instances_by_class('asteroide');
  for (i = 0, len = asteroides.length; i < len; i++) {
    ast = asteroides[i];
    ast.pos = ast.pos.add(ast.vel.mul_by_scalar(fator));
    ajusta_posicao_wrap(ast, limite_x, limite_y);
  }
  tiros = ls.get_instances_by_class('tiro');
  for (j = 0, len1 = tiros.length; j < len1; j++) {
    tiro = tiros[j];
    tiro.pos = tiro.pos.add(tiro.vel.mul_by_scalar(0.1));
    // verifica se o tiro saiu da tela
    // se sim, remove o tiro
    if (tiro.pos.x > limite_x || tiro.pos.x < -limite_x || tiro.pos.y > limite_y || tiro.pos.y < -limite_y) {
      tiro.remove();
    }
  }
  coisas = ls.get_instances_by_class('coisa');
  for (k = 0, len2 = coisas.length; k < len2; k++) {
    coisa = coisas[k];
    coisa.pos = coisa.pos.add(coisa.vel.mul_by_scalar(fator));
  }
  if (nave != null) {
    ang_inc = 3;
    y_inc = 0;
    if (teclas['ArrowUp'] >= 1) {
      y_inc = 1;
    } else if (teclas['ArrowDown'] >= 1) {
      y_inc = -1;
    }
    if (apertando_tecla('ArrowLeft')) {
      nave.ang += ang_inc;
    } else if (apertando_tecla('ArrowRight')) {
      nave.ang -= ang_inc;
    }
    if (apertou_tecla(' ')) {
      cria_tiro(nave);
    }
    if (apertou_tecla('a')) {
      cria_asteroide();
    }
    if (apertou_tecla('c')) {
      cria_coisa();
    }
    if (apertou_tecla('e')) {
      cria_explosao(vec_random());
    }
    v = vec(0, 1, 0);
    R = mat.rotate(nave.ang);
    nave.frente = mat_mul(R, v);
    if (y_inc !== 0) {
      nave.vel = nave.vel.add(nave.frente.mul_by_scalar(fator * y_inc));
    }
    nave.pos = nave.pos.add(nave.vel.mul_by_scalar(fator));
    nave.vel = nave.vel.mul_by_scalar(0.95);
    ajusta_posicao_wrap(nave, limite_x, limite_y);
  }
  // --- LÓGICA DE COLISÃO ---
  tiros = ls.get_instances_by_class('tiro');
  asteroides = ls.get_instances_by_class('asteroide');
  for (l = 0, len3 = tiros.length; l < len3; l++) {
    tiro = tiros[l];
    for (m = 0, len4 = asteroides.length; m < len4; m++) {
      ast = asteroides[m];
      raio_tiro = 0.5;
      raio_ast = ast.size;
      
      // --- CÁLCULO MANUAL DA DISTÂNCIA AO QUADRADO ---
      dx = tiro.pos.x - ast.pos.x;
      dy = tiro.pos.y - ast.pos.y;
      dist_sqr = (dx * dx) + (dy * dy);
      soma_raios_sqr = (raio_tiro + raio_ast) ** 2;
      if (dist_sqr < soma_raios_sqr) {
        cria_explosao(ast.pos);
        tiro.remove();
        ast.remove();
        break;
      }
    }
  }
  
  // --- LÓGICA DE COLISÃO ENTRE NAVE E ASTEROIDES ---
  if (nave != null) {
    // Pega a lista de asteroides novamente, pois ela pode ter sido modificada pelos tiros
    asteroides = ls.get_instances_by_class('asteroide');
    for (n = 0, len5 = asteroides.length; n < len5; n++) {
      ast = asteroides[n];
      raio_nave = 0.3; // Raio aproximado da nave
      
      // Calcula a distância entre a nave e o asteroide
      dx = nave.pos.x - ast.pos.x;
      dy = nave.pos.y - ast.pos.y;
      
      // Se a distância for menor que a soma dos raios, houve colisão
      if ((dx * dx + dy * dy) < (raio_nave + ast.size) ** 2) {
        cria_explosao_nave(nave.pos); // Cria uma explosão na posição da nave
        nave.remove(); // Remove a nave antiga
        nave = null; // Define a nave como nula para evitar erros
        ast.remove(); // Remove o asteroide
        
        // Chama a função para resetar e dar respawn após 1.5 segundos
        setTimeout(reset_game, 1500);
        break; // Para o loop, pois a nave já foi destruída
      }
    } // Só executa se a nave existir
  }
  
  // --- LÓGICA DE SPAWN DE ASTEROIDES ---
  asteroides_atuais = ls.get_instances_by_class('asteroide');
  if (asteroides_atuais.length < max_asteroides) {
    contador_spawn_asteroide++;
    if (contador_spawn_asteroide >= intervalo_spawn_asteroide) {
      cria_asteroide();
      return contador_spawn_asteroide = 0; // Reseta o contador
    }
  }
};

// -----------------------------------
TRS = function(pos, ang, rx, ry, rz, scale_factor) {
  var R, S, T;
  S = mat.scale(scale_factor);
  R = mat.rotate(ang, rx, ry, rz);
  T = mat.translate(pos);
  return mat.mul(T, R, S);
};

atualiza_uniforms = function() {
  var cl, i, inst, len, ref, u;
  multiplayer_send_to_server();
  ref = ls.instances();
  for (i = 0, len = ref.length; i < len; i++) {
    inst = ref[i];
    u = inst.get_uniform_data();
    cl = inst.get_class();
    switch (cl) {
      case 'nave':
        u.model = TRS(nave.pos, nave.ang, 0, 0, 1, 0.3);
        break;
      case 'asteroide':
        u.model = TRS(inst.pos, inst.ang, 1, 1, 1, inst.size);
        inst.ang += 5;
        break;
      case 'tiro':
        u.model = TRS(inst.pos, inst.ang, 0, 0, 1, 0.5);
        inst.ang += 10;
        break;
      case 'coisa':
      case 'explosao':
        u.model = TRS(inst.pos, 0, 0, 0, 0, inst.size);
        break;
      case 'multiplayer-nave':
        u.model = TRS(inst.pos, inst.ang, 0, 0, 1, 0.3);
    }
  }
  return gr.dados_instancias.gpu_send();
};

main();
